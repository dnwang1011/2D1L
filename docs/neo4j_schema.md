# Neo4j Schema for 2Dots1Line V7

This document outlines the node labels and relationship types for the Neo4j graph database.

## Node Labels

*   **`User`**: Represents a user of the system.
    *   Properties:
        *   `userId`: STRING (Primary Key, from PostgreSQL)
        *   `email`: STRING (Indexed)
        *   `name`: STRING (Optional)
        *   `createdAt`: DATETIME (Timestamp of creation in Neo4j, if synced)

*   **`Concept`**: Represents an abstract concept or entity extracted or defined.
    *   Properties:
        *   `conceptId`: STRING (Primary Key, UUID)
        *   `name`: STRING (Indexed, for search)
        *   `description`: STRING (Optional)
        *   `type`: STRING (e.g., 'Person', 'Location', 'Topic', 'UserDefinedTag') (Indexed)
        *   `createdAt`: DATETIME
        *   `updatedAt`: DATETIME

*   **`MemoryUnit`**: Represents an ingested piece of content (e.g., a document, webpage, image meta).
    *   Properties:
        *   `memoryUnitId`: STRING (Primary Key, UUID)
        *   `sourceUri`: STRING (Optional, URL or path to original content)
        *   `contentType`: STRING (e.g., 'text/plain', 'application/pdf', 'image/jpeg')
        *   `contentHash`: STRING (Optional, hash of the original raw content)
        *   `createdAt`: DATETIME
        *   `updatedAt`: DATETIME

*   **`Chunk`**: Represents a processed segment of a `MemoryUnit` (e.g., text paragraph, image region).
    *   Properties:
        *   `chunkId`: STRING (Primary Key, UUID)
        *   `textContent`: STRING (For text chunks, indexed for full-text search if Neo4j Aura supports it, otherwise primarily for context. Vector embeddings will be in Weaviate)
        *   `sequenceIndex`: INTEGER (Order within the parent `MemoryUnit`)
        *   `metadata`: STRING (JSON string for additional chunk-specific data, e.g., page number, bounding box)
        *   `createdAt`: DATETIME

*   **`Annotation`**: Represents a user-created note or highlight on a `Chunk`.
    *   Properties:
        *   `annotationId`: STRING (Primary Key, UUID)
        *   `textContent`: STRING (The content of the annotation itself)
        *   `selector`: STRING (JSON string, e.g., text position, bounding box, for where the annotation applies on the chunk)
        *   `createdAt`: DATETIME
        *   `updatedAt`: DATETIME

*   **`DerivedArtifact`**: Represents content generated by agents (e.g., summaries, insights, hypotheses).
    *   Properties:
        *   `artifactId`: STRING (Primary Key, UUID)
        *   `type`: STRING (e.g., 'Summary', 'Insight', 'Hypothesis', 'UserChallengeProgress') (Indexed)
        *   `title`: STRING (Optional)
        *   `contentJson`: STRING (JSON string representing the artifact's structured content)
        *   `createdAt`: DATETIME
        *   `updatedAt`: DATETIME

*   **`Orb`**: Represents a user-curated collection or workspace.
    *   Properties:
        *   `orbId`: STRING (Primary Key, UUID from PostgreSQL)
        *   `name`: STRING
        *   `description`: STRING (Optional)
        *   `createdAt`: DATETIME
        *   `updatedAt`: DATETIME

## Relationship Types

*   **`:OWNS_USER`** (`(:User)-[:OWNS_USER]->(:User {userId: 'system'})` or similar if needed for system ownership, or simply rely on `userId` properties)
*   **`:HAS_MEMORY_UNIT`** (`(:User)-[:HAS_MEMORY_UNIT]->(:MemoryUnit)`)
    *   Properties: `addedAt`: DATETIME
*   **`:CREATED_ANNOTATION`** (`(:User)-[:CREATED_ANNOTATION]->(:Annotation)`)
*   **`:GENERATED_ARTIFACT`** (`(:User)-[:GENERATED_ARTIFACT]->(:DerivedArtifact)`)
*   **`:OWNS_ORB`** (`(:User)-[:OWNS_ORB]->(:Orb)`)

*   **`:HAS_CHUNK`** (`(:MemoryUnit)-[:HAS_CHUNK]->(:Chunk)`)
    *   Properties: `processedAt`: DATETIME

*   **`:MENTIONS_CONCEPT`** (`(:Chunk)-[:MENTIONS_CONCEPT]->(:Concept)`)
    *   Properties: `relevance`: FLOAT (Optional, score from extraction), `provenance`: STRING (Optional, how it was mentioned)
*   **`:EMBEDS_CONCEPT_NODE`** (`(:Chunk)-[:EMBEDS_CONCEPT_NODE]->(:Concept)`) - *Alternative or specific type if chunk directly creates a concept node.*

*   **`:ANNOTATES_CHUNK`** (`(:Annotation)-[:ANNOTATES_CHUNK]->(:Chunk)`)
*   **`:HIGHLIGHTS_CONCEPT`** (`(:Annotation)-[:HIGHLIGHTS_CONCEPT]->(:Concept)`)
    *   Properties: `isExplicit`: BOOLEAN (True if user explicitly tagged this concept)

*   **`:BASED_ON_CHUNK`** (`(:DerivedArtifact)-[:BASED_ON_CHUNK]->(:Chunk)`)
    *   Properties: `contribution_score`: FLOAT (Optional)
*   **`:REFERENCES_CONCEPT`** (`(:DerivedArtifact)-[:REFERENCES_CONCEPT]->(:Concept)`)
    *   Properties: `significance`: FLOAT (Optional)

*   **`:RELATED_TO`** (`(:Concept)-[:RELATED_TO]->(:Concept)`)
    *   Properties:
        *   `type`: STRING (e.g., 'broader', 'narrower', 'synonym', 'causes', 'effect_of', 'part_of', 'user_defined') (Indexed)
        *   `weight`: FLOAT (Optional, strength of relationship, 0.0 to 1.0)
        *   `description`: STRING (Optional, notes about the relationship)
        *   `source`: STRING (Optional, 'user_defined', 'agent_inferred')

*   **`:CONTAINS_MEMORY_UNIT`** (`(:Orb)-[:CONTAINS_MEMORY_UNIT]->(:MemoryUnit)`)
    *   Properties: `addedAt`: DATETIME
*   **`:CONTAINS_CONCEPT`** (`(:Orb)-[:CONTAINS_CONCEPT]->(:Concept)`)
    *   Properties: `addedAt`: DATETIME
*   **`:CONTAINS_ARTIFACT`** (`(:Orb)-[:CONTAINS_ARTIFACT]->(:DerivedArtifact)`)
    *   Properties: `addedAt`: DATETIME

## Indexes and Constraints (Example Cypher)

```cypher
// Unique constraints (also create indexes)
CREATE CONSTRAINT IF NOT EXISTS FOR (u:User) REQUIRE u.userId IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (c:Concept) REQUIRE c.conceptId IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (m:MemoryUnit) REQUIRE m.memoryUnitId IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (ch:Chunk) REQUIRE ch.chunkId IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (a:Annotation) REQUIRE a.annotationId IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (art:DerivedArtifact) REQUIRE art.artifactId IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (o:Orb) REQUIRE o.orbId IS UNIQUE;

// Indexes for faster lookups
CREATE INDEX IF NOT EXISTS FOR (u:User) ON (u.email);
CREATE INDEX IF NOT EXISTS FOR (c:Concept) ON (c.name);
CREATE INDEX IF NOT EXISTS FOR (c:Concept) ON (c.type);
CREATE INDEX IF NOT EXISTS FOR (art:DerivedArtifact) ON (art.type);

// Full-text search index (if available and needed for chunk textContent)
// CREATE FULLTEXT INDEX chunkTextContentIndex IF NOT EXISTS FOR (n:Chunk) ON EACH [n.textContent];
``` 